# ======================================================================
# imports and definitions
# ======================================================================

from numpy import np
from itertools import product
from pysmt.shortcuts import And,  Equals,  Implies,  Int,  Not,  Or,  Solver,  Symbol
from pysmt.typing import INT

regions = [
    [0, 1, 1, 1, 9, 10, 10, 12, 12], 
    [0, 1, 6, 6, 9, 11, 10, 12, 13], 
    [0, 2, 2, 6, 6, 11, 11, 13, 13], 
    [0, 2, 3, 3, 6, 11, 15, 14, 14], 
    [0, 3, 3, 7, 7,  7, 15, 16, 16], 
    [0, 4, 3, 3, 3,  7, 15, 15, 16], 
    [0, 4, 4, 5, 8,  7, 17, 17, 18], 
    [0, 0, 5, 5, 8,  7, 17, 17, 18], 
    [0, 5, 5, 8, 8,  7,  7, 18, 18], 
]

R = range(9)
H = range(8)
K = range(19)

# helper functions
def indices(k):
    ''' list of indices that belong to region k '''
    return [(i, j) for i, j in product(R, R) if regions[i][j] == k]


# ======================================================================
# initialize variables
# ======================================================================

x = [[Symbol(f'x{i}{j}', INT) for j in R] for i in R]
h = [Symbol(f'h{i}', INT) for i in H]
s = Symbol('s', INT)


# ======================================================================
# constraints
# ======================================================================

given = Equals(x[0][2], Int(8))

# x <- {0,...,9} and h <- {0,...,3}
bounds_x = And([0 <= x[i][j] & x[i][j] <= 9 for i, j in product(R, R)])
bounds_h = And([0 <= h[i] & h[i] <= 3 for i in H])


# every 2x2 region must contain at least one unfilled square
def aux_unfilled(i, j):
    return Equals(Int(0), x[i][j] * x[i+1][j] * x[i][j+1] * x[i+1][j+1])
unfilled = And([aux_unfilled(i, j) for i, j in product(H, H)])


# the sum of the values in each of the connected regs must be the same 
sums = And([Equals(s, sum([x[i][j] for i, j in indices(k)])) for k in K])


# ======================================================================
# solve
# ======================================================================

formula = True
solver = Solver()
solver.add_assertion(formula)
if solver.solve():
    A = [[solver.get_value(x[i][j]).constant_value() for j in R] for i in R]


board = np.array(A)